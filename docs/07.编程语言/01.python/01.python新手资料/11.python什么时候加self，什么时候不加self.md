---
title: python什么时候加self，什么时候不加self
date: 2020-10-13 04:52:39
permalink: /pages/3c2e77/
categories:
  - python
  - python新手资料
tags:
  - 
---
1、self是什么，一般都说指对象本身，这样说了没了用，说了后还是很难懂，因为这样说了后，仍然完全搞不清楚，什么时候变量前需要加self，什么时候不需要加self。

造成很多人，已经怕了self，不停地测试，加self减self来测试代码，或者干脆不知道要不要self，所有变量前面一律加self，这样就能瞎猫碰死老鼠了，但不弄清楚，长期这样做法有点悲剧。

2、所以不需要这么去想self代表对象本身，换个思维应该认为self是全局变量，如果变量前面加了self，那么在任何实例方法（非staticmethod和calssmethod）就都可以访问这个变量了，如果没有加self，只有在当前函数内部才能访问这个变量。

3、根据pep8，所有的加了self的变量，需要确保是在\_\_init\_\_中首次出现，这是因为和java不一样，python没有成员声明，python一下子很难知道有哪些成员变量，所以最好确保所有带self前缀的变量是在\_\_init\_\_中首次出现。这条规则可以使用pycahrm的静态检查来证实或者pylint工具来证明。

4、重中之重就是前缀带self的变量，就是在整个类的代码块里面类似是作为全局变量，这样想后就不会出现不知道要不要self或者瞎全加self。

5、错误的例子就是这样，比如unitetst用例里面：

def test\_login(self):

     self.url = xxx

     self.resp = self.session.get(self.url)

     self.text = self.resp.text

     self.status = self.resp.statuscode

要加这么多self干鸟。这些都是局部的，别的方法里面不需要访问这些变量，完全是需要去掉这些self。

除了session属性需要共用以外，其他都要去掉，不然造成很大的误导，会以为这些变量也需要在其他方法中去使用它。

6、叫this或者任何其他的也可以，但是self是pycharm自动补全出来的，没必要再手动修改搞成this。

class A():
    def \_\_init\_\_(self,x):
        self.x = x

    def show(this):
        print(this.x)

A(1).show()

7、为什么不直接在类下面写，然后使用类方法cls.xxx访问，self和cls区别？
类属性是所有实例共享一份，需要看情况，需要多实例并且属性互不干扰需要使用self，需要所有实例保持使用同一个属性使用类属性。
一个类的多个实例就相当于一个模块的无限复制，但这些实例（伪模块）的内部状态（全局变量）是存在多份的，互不干扰的，这是使用面向对象很大的一个优点。模块和类的实例可以比较，拿函数和类比区别，简直是问得牛头不对马嘴的伪问题，就是问吃饭和人有什么区别 嘴巴和人有什么区别一样，问人和猪有什么区别才值得回答。

8.如果代码没有使用面向对象封装，只是有class外壳，那就直接写成函数好了，没有slef的困扰。否则即使写了class 类也是无效装逼废物类，这种类是怎么样的，需要怎么改变成有效面向对象类，需要看面向对象四步走里面的博客

# [关于pythoh面向过程开发人员三步转面向对象的补充，再加一步，四步走战略。转面向对象也可以有固定公式。](https://www.cnblogs.com/ydf0509/p/9265536.html)

。
上面说的是从思想上面怎么判断力一个类是不是无效废物类，那么从代码层面如何判断呢？很简单吧所有类的方法上加上@classmethod，所有代码还能正常直接运行，这种情况下，除了需要作为纯工具类以外，9成9就是无效废物类类，这种调用 类名 + 方法不如直接写成 模块 + 函数来调用。

贴一个无效废物类，里面没有成员变量也没有调用成员变量

![](https://img2018.cnblogs.com/blog/1108990/201903/1108990-20190302215414251-1718697002.png)

就算是吧add方法和print\_something方法换成静态方法，稍微说得过去，如果类里面没有其他方法和成员变量和实例方法，那也算无效装逼废物滑稽类。

反对极端面向过程编程思维方式，喜欢面向对象和设计模式的解读，喜欢对比极端面向过程编程和oop编程消耗代码代码行数的区别和原因。致力于使用oop和36种设计模式写出最高可复用的框架级代码和使用最少的代码行数完成任务，致力于使用oop和设计模式来使部分代码减少90%行，使绝大部分py文件最低减少50%\-80%行的写法。
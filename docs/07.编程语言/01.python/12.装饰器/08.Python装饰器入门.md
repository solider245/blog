在有关装饰器的本教程中，我们将了解它们是什么以及如何创建和使用它们。装饰器提供了用于调用[高阶函数](http://en.wikipedia.org/wiki/Higher-order_function)的简单语法。

根据定义，装饰器是一个函数，它接受另一个函数并扩展后一个函数的行为，而无需显式修改它。

这听起来令人困惑，但实际上并非如此，尤其是在您看到一些装饰器如何工作的示例之后。您可以[在此处](https://github.com/realpython/materials/tree/master/primer-on-python-decorators)找到本文中的所有示例。

**更新：** 

*   _2018年8月22日：_重大更新添加了更多示例和更多高级装饰器
*   2016年1月_12日：将_示例更新为Python 3（v3.5.1）语法，并添加了新示例
*   _2015年11月1日：_添加了关于`functools.wraps()`装饰器的简要说明

职能[](#functions "永久链接")
-----------------------

在了解装饰器之前，您必须首先了解函数的工作方式。就我们的目的而言，**函数基于给定的arguments返回值**。这是一个非常简单的示例：

\>>>

```
`>>> def add_one(number):
...     return number + 1

>>> add_one(2)
3` 
```

通常，Python中的函数可能还会有副作用，而不仅仅是将输入转换为输出。[该`print()`函数](https://realpython.com/python-print/)是[该](https://realpython.com/python-print/)[函数](https://realpython.com/python-print/)的一个基本示例：它在[返回结果的](https://realpython.com/python-return-statement/) [`None`](https://realpython.com/null-in-python/)同时会向控制台输出内容。但是，要了解装饰器，将函数视为将给定参数转换为值的东西就足够了。

**注意：** 在[函数式编程中](https://en.wikipedia.org/wiki/Functional_programming)，您（几乎）仅使用纯函数而没有副作用。虽然不是纯粹的功能语言，但是Python支持许多功能编程概念，包括作为一流对象的功能。

### 一流的对象[](#first-class-objects "永久链接")

在Python中，函数是[一流的对象](https://dbader.org/blog/python-first-class-functions)。这意味着**函数可以**像[其他任何对象（字符串，整数，浮点数，列表等）](https://realpython.com/python-data-types/)一样**传递并用作参数**。请考虑以下三个功能：

```
`def say_hello(name):
    return f"Hello {name}"

def be_awesome(name):
    return f"Yo {name}, together we are the awesomest!"

def greet_bob(greeter_func):
    return greeter_func("Bob")` 
```

在这里，`say_hello()`和`be_awesome()`是期望以字符串形式给出名称的常规函数​​。`greet_bob()`但是，该函数需要一个函数作为其参数。例如，我们可以将`say_hello()`或`be_awesome()`函数传递给它：

\>>>

```
`>>> greet_bob(say_hello)
'Hello Bob'

>>> greet_bob(be_awesome)
'Yo Bob, together we are the awesomest!'` 
```

请注意，它`greet_bob(say_hello)`指的是两个函数，但使用的方式不同：`greet_bob()`和`say_hello`。该`say_hello`函数的名称不带括号。这意味着仅传递对该函数的引用。该功能未执行。`greet_bob()`另一方面，该函数用括号编写，因此将照常调用它。

### 内部功能[](#inner-functions "永久链接")

可以_在其他函数中_[定义](https://realpython.com/defining-your-own-python-function/) _函数_。这些功能称为[内部功能](https://realpython.com/inner-functions-what-are-they-good-for/)。这是带有两个内部函数的函数示例：

```
`def parent():
    print("Printing from the parent() function")

    def first_child():
        print("Printing from the first_child() function")

    def second_child():
        print("Printing from the second_child() function")

    second_child()
    first_child()` 
```

调用该`parent()`函数会怎样？仔细考虑一下。输出如下：

\>>>

```
`>>> parent()
Printing from the parent() function
Printing from the second_child() function
Printing from the first_child() function` 
```

注意，定义内部功能的顺序无关紧要。与任何其他功能一样，仅当执行内部功能时才进行打印。

此外，在调用父函数之前，不定义内部函数。它们在局部范围内`parent()`：仅`parent()`作为局部[变量](https://realpython.com/python-variables/)存在于函数内部。尝试致电`first_child()`。您应该得到一个错误：

```
`Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'first_child' is not defined` 
```

每当调用时`parent()`，内部函数`first_child()`和`second_child()`也会被调用。但是由于它们的本地范围，它们在`parent()`功能之外不可用。

### 从函数返回函数[](#returning-functions-from-functions "永久链接")

Python还允许您将函数用作返回值。下面的示例从外部`parent()`函数返回内部函数之一：

```
`def parent(num):
    def first_child():
        return "Hi, I am Emma"

    def second_child():
        return "Call me Liam"

    if num == 1:
        return first_child
    else:
        return second_child` 
```

请注意，您返回时`first_child`没有括号。回想一下，这意味着您正在**返回对该函数的引用`first_child`**。`first_child()`与括号相反是指评估功能的结果。在以下示例中可以看到：

\>>>

```
`>>> first = parent(1)
>>> second = parent(2)

>>> first
<function parent.<locals>.first_child at 0x7f599f1e2e18>

>>> second
<function parent.<locals>.second_child at 0x7f599dad5268>` 
```

输出有些晦涩难懂，仅表示该`first`变量引用`first_child()`内部的局部函数`parent()`，而`second`指向`second_child()`。

现在`first`，您可以使用并且`second`就好像它们是常规函数一样，即使它们指向的函数不能直接访问：

\>>>

```
`>>> first()
'Hi, I am Emma'

>>> second()
'Call me Liam'` 
```

最后，请注意，在前面的示例中，您在父函数中执行了内部函数，例如`first_child()`。但是，在最后一个示例中，您没有在内部函数中添加括号（`first_child`返回时）。这样，您就可以引用将来可以调用的每个函数。说得通？

简单的装饰器[](#simple-decorators "永久链接")
-----------------------------------

既然您已经看到函数就像Python中的任何其他对象一样，您就可以继续前进，并看到Python装饰器这一神奇的野兽。让我们从一个例子开始：

```
`def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

def say_whee():
    print("Whee!")

say_whee = my_decorator(say_whee)` 
```

你能猜出打电话时会发生什么`say_whee()`吗？试试看：

\>>>

```
`>>> say_whee()
Something is happening before the function is called.
Whee!
Something is happening after the function is called.` 
```

要了解这里发生的情况，请回顾前面的示例。从字面上看，我们只是在应用您到目前为止所学的所有知识。

所谓的修饰发生在以下行：

```
`say_whee = my_decorator(say_whee)` 
```

实际上，该名称`say_whee`现在指向`wrapper()`内部函数。请记住，您`wrapper`在调用时作为函数返回`my_decorator(say_whee)`：

\>>>

```
`>>> say_whee
<function my_decorator.<locals>.wrapper at 0x7f3c5dfd42f0>` 
```

但是，`wrapper()`对的引用`say_whee()`为`func`，并且在的两次调用之间调用该函数[`print()`](https://realpython.com/courses/python-print/)。

简而言之：**装饰器包装一个函数，修改其行为。** 

在继续之前，让我们看第二个例子。因为`wrapper()`是常规的Python函数，所以修饰器修改函数的方式可以动态更改。为了不打扰您的邻居，下面的示例仅在白天运行经过修饰的代码：

```
`from datetime import datetime

def not_during_the_night(func):
    def wrapper():
        if 7 <= datetime.now().hour < 22:
            func()
        else:
            pass  # Hush, the neighbors are asleep
    return wrapper

def say_whee():
    print("Whee!")

say_whee = not_during_the_night(say_whee)` 
```

如果您尝试`say_whee()`在睡前打电话，将不会发生任何事情：

### 语法糖！[](#syntactic-sugar "永久链接")

您`say_whee()`上面装饰的方式有点笨拙。首先，您最终要键入`say_whee`三次该名称。另外，在函数的定义之下，装饰也隐藏了一些。

取而代之的是，Python允许您以**更简单的方式将装饰`@`符与符号**（有时称为[“派”语法）一起使用](https://www.python.org/dev/peps/pep-0318/#background)。下面的示例与第一个装饰器示例完全相同：

```
`def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_whee():
    print("Whee!")` 
```

因此，`@my_decorator`这只是一种更简单的说法`say_whee = my_decorator(say_whee)`。这就是将装饰器应用于函数的方式。

### 重用装饰器[](#reusing-decorators "永久链接")

回想一下，装饰器只是一个常规的Python函数。提供了所有易于重用的常用工具。让我们将装饰器移至可以在许多其他功能中使用的[模块](https://realpython.com/python-modules-packages/)。

创建一个`decorators.py`具有以下内容的文件：

```
`def do_twice(func):
    def wrapper_do_twice():
        func()
        func()
    return wrapper_do_twice` 
```

**注意：** 您可以随意命名内部函数，`wrapper()`通常可以使用通用名称。您将在本文中看到很多装饰器。为了使它们分开，我们将内部函数命名为与装饰器相同的名称，但带有`wrapper_`前缀。

现在，您可以通过常规[导入](https://realpython.com/absolute-vs-relative-python-imports/)在其他文件中使用此新装饰器：

```
`from decorators import do_twice

@do_twice
def say_whee():
    print("Whee!")` 
```

运行此示例时，您应该看到原始代码`say_whee()`执行了两次：

\>>>

```
`>>> say_whee()
Whee!
Whee!` 
```

### 用参数装饰函数[](#decorating-functions-with-arguments "永久链接")

假设您有一个接受某些参数的函数。你还能装饰吗？我们试试吧：

```
`from decorators import do_twice

@do_twice
def greet(name):
    print(f"Hello {name}")` 
```

不幸的是，运行以下代码会引发错误：

\>>>

```
`>>> greet("World")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: wrapper_do_twice() takes 0 positional arguments but 1 was given` 
```

问题在于内部函数`wrapper_do_twice()`不接受任何参数，而是`name="World"`传递给它。您可以通过`wrapper_do_twice()`接受一个参数来解决此问题，但不适用于`say_whee()`您先前创建的函数。

解决的办法是在内部包装函数中使用[`*args`和`**kwargs`](https://realpython.com/python-kwargs-and-args/)。然后它将接受任意数量的位置和关键字参数。重写`decorators.py`如下：

```
`def do_twice(func):
 def wrapper_do_twice(*args, **kwargs): func(*args, **kwargs) func(*args, **kwargs)    return wrapper_do_twice` 
```

的`wrapper_do_twice()`内函数现在接受任何数量的参数，并把它们传递到其装饰功能。现在，您`say_whee()`和`greet()`示例都可以使用：

\>>>

```
`>>> say_whee()
Whee!
Whee!

>>> greet("World")
Hello World
Hello World` 
```

### 从装饰函数返回值[](#returning-values-from-decorated-functions "永久链接")

装饰函数的返回值会怎样？好吧，这取决于装饰者来决定。假设您装饰了一个简单的函数，如下所示：

```
`from decorators import do_twice

@do_twice
def return_greeting(name):
    print("Creating greeting")
    return f"Hi {name}"` 
```

尝试使用它：

\>>>

```
`>>> hi_adam = return_greeting("Adam")
Creating greeting
Creating greeting
>>> print(hi_adam)
None` 
```

糟糕，您的装饰器会吃掉函数的返回值。

由于`do_twice_wrapper()`并未明确返回值，因此调用`return_greeting("Adam")`最终返回`None`。

要解决此问题，您需要**确保包装函数返回装饰函数的返回值**。更改`decorators.py`文件：

```
`def do_twice(func):
    def wrapper_do_twice(*args, **kwargs):
        func(*args, **kwargs)
 return func(*args, **kwargs)    return wrapper_do_twice` 
```

返回上一次执行该函数的返回值：

\>>>

```
`>>> return_greeting("Adam")
Creating greeting
Creating greeting
'Hi Adam'` 
```

### 你到底是谁？[](#who-are-you-really "永久链接")

使用Python时（特别是在交互式shell中），极大的便利是其强大的自省功能。[内省](https://en.wikipedia.org/wiki/Type_introspection)是对象在运行时知道其自身属性的能力。例如，一个函数知道自己的名称和[文档](https://realpython.com/documenting-python-code/)：

\>>>

```
`>>> print
<built-in function print>

>>> print.__name__
'print'

>>> help(print)
Help on built-in function print in module builtins:

print(...)
 <full help message>` 
```

内省适用于您自己定义的函数：

\>>>

```
`>>> say_whee
<function do_twice.<locals>.wrapper_do_twice at 0x7f43700e52f0>

>>> say_whee.__name__
'wrapper_do_twice'

>>> help(say_whee)
Help on function wrapper_do_twice in module decorators:

wrapper_do_twice()` 
```

但是，在被装饰后，`say_whee()`对其身份变得非常困惑。现在报告它`wrapper_do_twice()`是`do_twice()`装饰器内部的功能。尽管从技术上讲是正确的，但这不是非常有用的信息。

要解决此问题，装饰器应使用[`@functools.wraps`](https://docs.python.org/library/functools.html#functools.wraps)装饰器，该装饰器将保留有关原始功能的信息。`decorators.py`再次更新：

```
`import functools 
def do_twice(func):
 @functools.wraps(func)    def wrapper_do_twice(*args, **kwargs):
        func(*args, **kwargs)
        return func(*args, **kwargs)
    return wrapper_do_twice` 
```

您不需要更改任何有关修饰`say_whee()`函数的内容：

\>>>

```
`>>> say_whee
<function say_whee at 0x7ff79a60f2f0>

>>> say_whee.__name__
'say_whee'

>>> help(say_whee)
Help on function say_whee in module whee:

say_whee()` 
```

好多了！现在`say_whee()`仍然是经过装修的本身。

**技术细节：** 该`@functools.wraps`装饰[使用](https://github.com/python/cpython/blob/5d4cb54800966947db2e86f65fb109c5067076be/Lib/functools.py#L34)的功能`functools.update_wrapper()`更新之类的特殊属性`__name__`和`__doc__`那些在反省中。

现实世界中的一些例子[](#a-few-real-world-examples "永久链接")
-----------------------------------------------

让我们看一些装饰器的有用示例。您会注意到，它们将主要遵循您到目前为止所学的相同模式：

```
`import functools

def decorator(func):
    @functools.wraps(func)
    def wrapper_decorator(*args, **kwargs):
        # Do something before
        value = func(*args, **kwargs)
        # Do something after
        return value
    return wrapper_decorator` 
```

此公式是用于构建更复杂的装饰器的良好样板模板。

**注意：** 在后面的示例中，我们将假定这些装饰器也保存在`decorators.py`文件中。回想一下，您可以下载[本教程中的所有示例](https://github.com/realpython/materials/tree/master/primer-on-python-decorators)。

### 计时功能[](#timing-functions "永久链接")

让我们开始创建一个`@timer`装饰器。它将[测量函数执行所需](https://realpython.com/python-timer/)的时间并将持续时间打印到控制台。这是代码：

```
`import functools
import time

def timer(func):
    """Print the runtime of the decorated function"""
    @functools.wraps(func)
    def wrapper_timer(*args, **kwargs):
        start_time = time.perf_counter()    # 1
        value = func(*args, **kwargs)
        end_time = time.perf_counter()      # 2
        run_time = end_time - start_time    # 3
        print(f"Finished {func.__name__!r} in {run_time:.4f} secs")
        return value
    return wrapper_timer

@timer
def waste_some_time(num_times):
    for _ in range(num_times):
        sum([i**2 for i in range(10000)])` 
```

该装饰器的工作原理是存储函数开始运行之前（在标记为的行`# 1`）和函数完成之后（在`# 2`）的时间。函数所花费的时间就是两者之间的差值（at `# 3`）。我们使用该[`time.perf_counter()`](https://docs.python.org/library/time.html#time.perf_counter)功能，它可以很好地测量时间间隔。以下是一些计时示例：

\>>>

```
`>>> waste_some_time(1)
Finished 'waste_some_time' in 0.0010 secs

>>> waste_some_time(999)
Finished 'waste_some_time' in 0.3260 secs` 
```

自己运行。逐行处理代码。确保您了解其工作原理。不过，不要担心，如果您不了解它。装饰者是高级生物。尝试在上面睡觉或绘制程序流程图。

**注：** 该`@timer`装饰是伟大的，如果你只是想获得你的函数运行时的想法。如果要对代码进行更精确的测量，则应考虑标准库中的[`timeit`模块](https://docs.python.org/library/timeit.html)。它暂时禁用[垃圾收集，](https://realpython.com/python-memory-management/#garbage-collection)并运行多次试验以消除快速函数调用中的噪音。

### 调试代码[](#debugging-code "永久链接")

下面的`@debug`装饰器将打印调用函数的参数以及每次调用该函数时的返回值：

```
`import functools

def debug(func):
    """Print the function signature and return value"""
    @functools.wraps(func)
    def wrapper_debug(*args, **kwargs):
        args_repr = [repr(a) for a in args]                      # 1
        kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]  # 2
        signature = ", ".join(args_repr + kwargs_repr)           # 3
        print(f"Calling {func.__name__}({signature})")
        value = func(*args, **kwargs)
        print(f"{func.__name__!r} returned {value!r}")           # 4
        return value
    return wrapper_debug` 
```

通过连接所有参数的[字符串表示](https://dbader.org/blog/python-repr-vs-str)来创建签名。下表中的数字与代码中带注释的数字相对应：

1.  创建位置参数列表。使用`repr()`来获取表示每个参数一个不错的字符串。
2.  创建关键字参数列表。所述[F-串](https://realpython.com/python-f-strings/)格式化每个参数作为`key=value`其中`!r`该说明符的装置`repr()`被用来表示该值。
3.  位置和关键字参数的列表连接在一起成为一个签名字符串，每个参数用逗号分隔。
4.  执行该功能后，将打印返回值。

让我们看看装饰器在实践中是如何工作的，方法是将其应用于具有一个位置和一个关键字参数的简单函数：

```
`@debug
def make_greeting(name, age=None):
    if age is None:
        return f"Howdy {name}!"
    else:
        return f"Whoa {name}! {age} already, you are growing up!"` 
```

注意`@debug`装饰器如何打印`make_greeting()`函数的签名和返回值：

\>>>

```
`>>> make_greeting("Benjamin")
Calling make_greeting('Benjamin')
'make_greeting' returned 'Howdy Benjamin!'
'Howdy Benjamin!'

>>> make_greeting("Richard", age=112)
Calling make_greeting('Richard', age=112)
'make_greeting' returned 'Whoa Richard! 112 already, you are growing up!'
'Whoa Richard! 112 already, you are growing up!'

>>> make_greeting(name="Dorrisile", age=116)
Calling make_greeting(name='Dorrisile', age=116)
'make_greeting' returned 'Whoa Dorrisile! 116 already, you are growing up!'
'Whoa Dorrisile! 116 already, you are growing up!'` 
```

由于`@debug`装饰器仅重复您刚才编写的内容，因此该示例似乎并不立即有用。当将其应用于不直接自己调用的小型便利功能时，它会更强大。

下面的示例计算[数学常数_e_](https://en.wikipedia.org/wiki/E_(mathematical_constant))的近似值：

```
`import math
from decorators import debug

# Apply a decorator to a standard library function
math.factorial = debug(math.factorial)

def approximate_e(terms=18):
    return sum(1 / math.factorial(n) for n in range(terms))` 
```

此示例还显示了如何将装饰器应用于已定义的函数。_e_的近似值基于以下[级数展开](https://en.wikipedia.org/wiki/E_(mathematical_constant))：

[![](https://files.realpython.com/media/e_series_long.7ce8d6492b4f.png)
](https://files.realpython.com/media/e_series_long.7ce8d6492b4f.png)

调用该`approximate_e()`函数时，您可以看到`@debug`装饰器在工作：

\>>>

```
`>>> approximate_e(5)
Calling factorial(0)
'factorial' returned 1
Calling factorial(1)
'factorial' returned 1
Calling factorial(2)
'factorial' returned 2
Calling factorial(3)
'factorial' returned 6
Calling factorial(4)
'factorial' returned 24
2.708333333333333` 
```

在此示例中，您仅对5个项进行了近似计算即可得出真实值_e_ = 2.718281828。

### 减速代码[](#slowing-down-code "永久链接")

下一个示例似乎不太有用。您为什么要放慢Python代码的速度？可能最常见的用例是您希望对一个函数进行速率限制，该函数可以连续检查资源（例如网页）是否已更改。该`@slow_down`装饰将睡一其次，它调用装饰函数之前：

```
`import functools
import time

def slow_down(func):
    """Sleep 1 second before calling the function"""
    @functools.wraps(func)
    def wrapper_slow_down(*args, **kwargs):
        time.sleep(1)
        return func(*args, **kwargs)
    return wrapper_slow_down

@slow_down
def countdown(from_number):
    if from_number < 1:
        print("Liftoff!")
    else:
        print(from_number)
        countdown(from_number - 1)` 
```

要查看`@slow_down`装饰器的效果，您确实需要自己运行示例：

\>>>

```
`>>> countdown(3)
3
2
1
Liftoff!` 
```

**注意：** 该`countdown()`函数是递归函数。换句话说，它是一个调用自身的函数。要了解有关Python中的递归函数的更多信息，请参阅《[Python中的递归思考》](https://realpython.com/python-thinking-recursively/)指南。

该`@slow_down`装饰总是睡一秒钟。[稍后](#slowing-down-code-revisited)，您将看到如何通过将参数传递给装饰器来控制速率。

### 注册插件[](#registering-plugins "永久链接")

装饰器不必包装正在装饰的功能。他们还可以简单地注册一个函数存在并返回未包装的函数。例如，可以使用它来创建轻量级的插件体系结构：

```
`import random
PLUGINS = dict()

def register(func):
    """Register a function as a plug-in"""
    PLUGINS[func.__name__] = func
    return func

@register
def say_hello(name):
    return f"Hello {name}"

@register
def be_awesome(name):
    return f"Yo {name}, together we are the awesomest!"

def randomly_greet(name):
    greeter, greeter_func = random.choice(list(PLUGINS.items()))
    print(f"Using {greeter!r}")
    return greeter_func(name)` 
```

该`@register`装饰简单地存储在全球的装饰功能的参考`PLUGINS`字典。请注意，您不必编写内部函数或`@functools.wraps`在此示例中使用它，因为您将返回未修改的原始函数。

该`randomly_greet()`功能随机选择要使用的已注册功能之一。请注意，该`PLUGINS`词典已经包含对注册为插件的每个功能对象的引用：

\>>>

```
`>>> PLUGINS
{'say_hello': <function say_hello at 0x7f768eae6730>,
 'be_awesome': <function be_awesome at 0x7f768eae67b8>}

>>> randomly_greet("Alice")
Using 'say_hello'
'Hello Alice'` 
```

这种简单的插件体系结构的主要优点是，您无需维护存在的插件列表。该列表在插件注册时创建。这使得添加新插件变得很简单：只需定义函数并用修饰`@register`。

如果您熟悉`globals()`Python，则可能会发现与插件架构的工作方式有些相似之处。`globals()`允许访问当前作用域中的所有全局变量，包括您的插件：

\>>>

```
`>>> globals()
{..., # Lots of variables not shown here.
 'say_hello': <function say_hello at 0x7f768eae6730>,
 'be_awesome': <function be_awesome at 0x7f768eae67b8>,
 'randomly_greet': <function randomly_greet at 0x7f768eae6840>}` 
```

使用`@register`装饰器，您可以创建自己的精选有趣变量列表，从而有效地从中手动选择一些功能`globals()`。

### 用户是否登录？[](#is-the-user-logged-in "永久链接")

在使用Web框架时，通常使用最后一个更高级的装饰器示例。在此示例中，我们使用[Flask](https://realpython.com/tutorials/flask/)设置了一个`/secret`网页，该网页仅对已登录或已通过身份验证的用户可见：

```
`from flask import Flask, g, request, redirect, url_for
import functools
app = Flask(__name__)

def login_required(func):
    """Make sure user is logged in before proceeding"""
    @functools.wraps(func)
    def wrapper_login_required(*args, **kwargs):
        if g.user is None:
            return redirect(url_for("login", next=request.url))
        return func(*args, **kwargs)
    return wrapper_login_required

@app.route("/secret")
@login_required
def secret():
    ...` 
```

尽管这给出了有关如何向Web框架添加身份验证的想法，但是通常不应该自己编写这些类型的装饰器。对于Flask，您可以改用[Flask-Login扩展](https://flask-login.readthedocs.io/en/latest/#flask_login.login_required)，它增加了更多的安全性和功能。

花式装饰[](#fancy-decorators "永久链接")
--------------------------------

到目前为止，您已经了解了如何创建简单的装饰器。您已经对什么是装饰器以及它们如何工作有了很好的了解。随意从本文中休息一下，练习您所学到的一切。

在本教程的第二部分中，我们将探索更多高级功能，包括如何使用以下功能：

*   [课堂装饰](#decorating-classes)
*   [一个功能上有多个装饰器](#nesting-decorators)
*   [带参数的装饰器](#decorators-with-arguments)
*   [可以选择接受参数的装饰器](#both-please-but-never-mind-the-bread)
*   [有状态的装饰](#stateful-decorators)
*   [类作为装饰器](#classes-as-decorators)

### 装饰类[](#decorating-classes "永久链接")

在类上可以使用两种不同的装饰器。第一个非常类似于您已经使用函数完成的工作：您可以**修饰类的方法**。这是在今天引入装饰工[的动机之一](https://www.python.org/dev/peps/pep-0318/#motivation)。

一些常用的装饰器甚至内建在Python是[`@classmethod`，`@staticmethod`](https://realpython.com/instance-class-and-static-methods-demystified/)和[`@property`](https://docs.python.org/library/functions.html#property)。的`@classmethod`和`@staticmethod`装饰被用来定义一个类中的方法[命名空间](https://realpython.com/python-namespaces-scope/)没有连接到这个类的一个特定实例。该`@property`装饰来定制[getter和setter](https://docs.python.org/howto/descriptor.html#properties)的类属性。展开下面的框，查看使用这些装饰器的示例。

The following definition of a `Circle` class uses the `@classmethod`, `@staticmethod`, and `@property` decorators:

```
`class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """Get value of radius"""
        return self._radius

    @radius.setter
    def radius(self, value):
        """Set radius, raise error if negative"""
        if value >= 0:
            self._radius = value
        else:
            raise ValueError("Radius must be positive")

    @property
    def area(self):
        """Calculate area inside circle"""
        return self.pi() * self.radius**2

    def cylinder_volume(self, height):
        """Calculate volume of cylinder with circle as base"""
        return self.area * height

    @classmethod
    def unit_circle(cls):
        """Factory method creating a circle with radius 1"""
        return cls(1)

    @staticmethod
    def pi():
        """Value of π, could use math.pi instead though"""
        return 3.1415926535` 
```

In this class:

*   `.cylinder_volume()` is a regular method.
*   `.radius` is a mutable property: it can be set to a different value. However, by defining a setter method, we can do some error testing to make sure it’s not set to a nonsensical negative number. Properties are accessed as attributes without parentheses.
*   `.area` is an immutable property: properties without `.setter()` methods can’t be changed. Even though it is defined as a method, it can be retrieved as an attribute without parentheses.
*   `.unit_circle()` is a class method. It’s not bound to one particular instance of `Circle`. Class methods are often used as factory methods that can create specific instances of the class.
*   `.pi()` is a static method. It’s not really dependent on the `Circle` class, except that it is part of its namespace. Static methods can be called on either an instance or the class.

The `Circle` class can for example be used as follows:

\>>>

```
`>>> c = Circle(5)
>>> c.radius
5

>>> c.area
78.5398163375

>>> c.radius = 2
>>> c.area
12.566370614

>>> c.area = 100
AttributeError: can't set attribute

>>> c.cylinder_volume(height=4)
50.265482456

>>> c.radius = -1
ValueError: Radius must be positive

>>> c = Circle.unit_circle()
>>> c.radius
1

>>> c.pi()
3.1415926535

>>> Circle.pi()
3.1415926535` 
```

让我们定义一个类，在其中使用[先前](#a-few-real-world-examples)的[`@debug`](#debugging-code)and[`@timer`](#timing-functions)装饰器装饰其某些方法：[](#a-few-real-world-examples)

```
`from decorators import debug, timer

class TimeWaster:
    @debug
    def __init__(self, max_num):
        self.max_num = max_num

    @timer
    def waste_time(self, num_times):
        for _ in range(num_times):
            sum([i**2 for i in range(self.max_num)])` 
```

使用此类，您可以看到装饰器的效果：

\>>>

```
`>>> tw = TimeWaster(1000)
Calling __init__(<time_waster.TimeWaster object at 0x7efccce03908>, 1000)
'__init__' returned None

>>> tw.waste_time(999)
Finished 'waste_time' in 0.3376 secs` 
```

在类上使用装饰器的另一种方法是**装饰整个类**。例如，这是在[Python 3.7](https://realpython.com/python37-new-features/)的新[`dataclasses`模块](https://realpython.com/python-data-classes/)中完成的：[](https://realpython.com/python37-new-features/)

```
`from dataclasses import dataclass

@dataclass
class PlayingCard:
    rank: str
    suit: str` 
```

语法的含义类似于函数装饰器。在上面的示例中，您可以通过编写完成装饰`PlayingCard = dataclass(PlayingCard)`。

一[类装饰的普遍使用](https://www.python.org/dev/peps/pep-3129/#rationale)是是一些使用案例一个简单的替代[元类](https://realpython.com/python-metaclasses/)。在这两种情况下，您都是动态更改类的定义。

编写类装饰器与编写函数装饰器非常相似。唯一的区别是装饰器将接收类而不是函数作为参数。实际上，[您在上面看到的](#a-few-real-world-examples)所有装饰器[都](#a-few-real-world-examples)将用作类装饰器。当您在类而不是函数上使用它们时，它们的效果可能不是您想要的。在以下示例中，`@timer`装饰器应用于一个类：

```
`from decorators import timer

@timer
class TimeWaster:
    def __init__(self, max_num):
        self.max_num = max_num

    def waste_time(self, num_times):
        for _ in range(num_times):
            sum([i**2 for i in range(self.max_num)])` 
```

装饰类不会修饰其方法。回想一下，这`@timer`只是的简写`TimeWaster = timer(TimeWaster)`。

在这里，`@timer`仅测量实例化类所花费的时间：

\>>>

```
`>>> tw = TimeWaster(1000)
Finished 'TimeWaster' in 0.0000 secs

>>> tw.waste_time(999)
>>>` 
```

[稍后](#creating-singletons)，您将看到一个示例，该示例定义了适当的类装饰器，即`@singleton`，确保了类的只有一个实例。

### 嵌套装饰器[](#nesting-decorators "永久链接")

您可以通过**将多个装饰器**彼此堆叠来将其**应用**到一个函数：

```
`from decorators import debug, do_twice

@debug
@do_twice
def greet(name):
    print(f"Hello {name}")` 
```

考虑一下装饰器是按照其列出的顺序执行的。换句话说，`@debug`来电`@do_twice`，要求`greet()`，或`debug(do_twice(greet()))`：

\>>>

```
`>>> greet("Eva")
Calling greet('Eva')
Hello Eva
Hello Eva
'greet' returned None` 
```

注意区别，如果我们改变的顺序`@debug`和`@do_twice`：

```
`from decorators import debug, do_twice

@do_twice @debug def greet(name):
    print(f"Hello {name}")` 
```

在这种情况下，`@do_twice`也将适用于`@debug`：

\>>>

```
`>>> greet("Eva")
Calling greet('Eva')
Hello Eva
'greet' returned None
Calling greet('Eva')
Hello Eva
'greet' returned None` 
```

### 带参数的装饰器[](#decorators-with-arguments "永久链接")

有时，**将参数传递给装饰器**很有用。例如，`@do_twice`可以扩展到`@repeat(num_times)`装饰器。然后可以将执行修饰后的函数的次数作为参数。

这将允许您执行以下操作：

```
`@repeat(num_times=4)
def greet(name):
    print(f"Hello {name}")` 
```

\>>>

```
`>>> greet("World")
Hello World
Hello World
Hello World
Hello World` 
```

考虑一下如何实现这一目标。

到目前为止，在后面写的名称`@`已指向可以用另一个函数调用的函数对象。为了保持一致，您需要`repeat(num_times=4)`返回一个可以充当装饰器的函数对象。幸运的是，您[已经知道如何返回函数](#returning-functions-from-functions)！通常，您需要以下内容：

```
`def repeat(num_times):
    def decorator_repeat(func):
        ...  # Create and return a wrapper function
    return decorator_repeat` 
```

通常，装饰器创建并返回一个内部包装器函数，因此完整编写示例将为您提供内部函数内的内部函数。尽管这听起来像是《[盗梦空间》电影](https://en.wikipedia.org/wiki/Inception)的编程等效内容，但我们稍后将对其进行梳理：

```
`def repeat(num_times):
    def decorator_repeat(func):
        @functools.wraps(func)
        def wrapper_repeat(*args, **kwargs):
            for _ in range(num_times):
                value = func(*args, **kwargs)
            return value
        return wrapper_repeat
    return decorator_repeat` 
```

看起来有些混乱，但是我们现在只将您多次看到的相同装饰器模式放到另一个`def`处理该装饰器参数的内部。让我们从最里面的功能开始：

```
`def wrapper_repeat(*args, **kwargs):
    for _ in range(num_times):
        value = func(*args, **kwargs)
    return value` 
```

此`wrapper_repeat()`函数采用任意参数，并返回修饰函数的值`func()`。该包装函数还包含调用装饰函数`num_times`时间的循环。这与您之前看到的包装函数没有什么不同，只不过它使用的`num_times`是必须从外部提供的参数。

迈出第一步，您将找到装饰器功能：

```
`def decorator_repeat(func):
    @functools.wraps(func)
    def wrapper_repeat(*args, **kwargs):
        ...
    return wrapper_repeat` 
```

同样，`decorator_repeat()`除了命名不同外，它看起来与您先前编写的装饰器函数完全相同。这是因为我们`repeat()`为最外层的功能保留了基本名称，即用户将调用的名称。

如您所见，最外面的函数返回对装饰器函数的引用：

```
`def repeat(num_times):
    def decorator_repeat(func):
        ...
    return decorator_repeat` 
```

`repeat()`函数中发生了一些细微的事情：

*   定义`decorator_repeat()`为内部函数意味着`repeat()`将引用一个函数对象`decorator_repeat`。之前，我们在`repeat`不带括号的情况下使用了该函数对象。定义带有参数的修饰符时，添加的括号是必需的。
*   该`num_times`参数似乎`repeat()`本身没有使用。但是通过传递`num_times`一个[闭包](https://realpython.com/inner-functions-what-are-they-good-for/)，该[闭包](https://realpython.com/inner-functions-what-are-they-good-for/)`num_times`将存储的值，直到以后将由所使用`wrapper_repeat()`。

完成所有设置后，让我们看看结果是否符合预期：

```
`@repeat(num_times=4)
def greet(name):
    print(f"Hello {name}")` 
```

\>>>

```
`>>> greet("World")
Hello World
Hello World
Hello World
Hello World` 
```

正是我们想要的结果。

### 都请，但不要介意面包[](#both-please-but-never-mind-the-bread "永久链接")

稍加注意，您还可以定义**可以使用和不使用参数的装饰器**。最有可能的是，您不需要此功能，但是拥有灵活性很高兴。

如上一节所述，当装饰器使用参数时，您需要添加一个额外的外部函数。挑战在于您的代码要确定是否已使用参数调用装饰器。

由于要装饰的函数仅在不带参数的情况下调用装饰器时才直接传递，因此该函数必须是可选参数。这意味着装饰器参数必须全部由关键字指定。您可以使用特殊`*`语法强制执行此操作，这意味着[以下所有参数均为纯关键字](https://www.python.org/dev/peps/pep-3102/)：

```
`def name(_func=None, *, kw1=val1, kw2=val2, ...):  # 1
    def decorator_name(func):
        ...  # Create and return a wrapper function.

    if _func is None:
        return decorator_name                      # 2
    else:
        return decorator_name(_func)               # 3` 
```

在这里，`_func`参数充当标记，指出装饰器是否已通过参数调用：

1.  如果`name`没有参数调用，则装饰函数将作为传入`_func`。如果已使用参数调用了该参数，`_func`则将为`None`，并且某些关键字参数可能已更改为其默认值。该`*`参数列表意味着其余的参数不能被称为位置参数。
2.  在这种情况下，用参数调用装饰器。返回一个装饰器函数，该函数可以读取和返回一个函数。
3.  在这种情况下，装饰器被调用而没有参数。立即将装饰器应用于该函数。

`@repeat`在上一节的装饰器上使用此样板，可以编写以下内容：

```
`def repeat(_func=None, *, num_times=2):
    def decorator_repeat(func):
        @functools.wraps(func)
        def wrapper_repeat(*args, **kwargs):
            for _ in range(num_times):
                value = func(*args, **kwargs)
            return value
        return wrapper_repeat

 if _func is None: return decorator_repeat else: return decorator_repeat(_func)` 
```

将此与原始版本进行比较`@repeat`。唯一的变化是添加的`_func`参数和最后的`if`\- `else`。

[](https://github.com/dabeaz/python-cookbook/blob/master/src/9/defining_a_decorator_that_takes_an_optional_argument/example.py)优秀的[Python Cookbook的](https://realpython.com/asins/1449340377/)[9.6节](https://github.com/dabeaz/python-cookbook/blob/master/src/9/defining_a_decorator_that_takes_an_optional_argument/example.py)介绍了使用的替代解决方案[`functools.partial()`](https://docs.python.org/library/functools.html#functools.partial)。

这些示例表明，`@repeat`现在可以使用带参数或不带参数的情况：

```
`@repeat
def say_whee():
    print("Whee!")

@repeat(num_times=3)
def greet(name):
    print(f"Hello {name}")` 
```

回想一下默认值为`num_times`2：

\>>>

```
`>>> say_whee()
Whee!
Whee!

>>> greet("Penny")
Hello Penny
Hello Penny
Hello Penny` 
```

### 有状态的装饰者[](#stateful-decorators "永久链接")

有时，拥有**一个可以跟踪state的装饰器**很有用。作为一个简单的示例，我们将创建一个装饰器，该装饰器对调用函数的次数进行计数。

**注意：** 在[本指南的开头](#functions)，我们讨论了基于给定参数返回值的纯函数。有状态的装饰器则相反，返回值将取决于当前状态以及给定的参数。

在[下一节中](#classes-as-decorators)，你将看到如何使用类，来保持状态。但是在简单的情况下，您也可以使用[函数属性](https://www.python.org/dev/peps/pep-0232/)：

```
`import functools

def count_calls(func):
    @functools.wraps(func)
    def wrapper_count_calls(*args, **kwargs):
        wrapper_count_calls.num_calls += 1
        print(f"Call {wrapper_count_calls.num_calls} of {func.__name__!r}")
        return func(*args, **kwargs)
    wrapper_count_calls.num_calls = 0
    return wrapper_count_calls

@count_calls
def say_whee():
    print("Whee!")` 
```

状态（对函数的调用次数）存储在`.num_calls`包装函数的function属性中。这是使用它的效果：

\>>>

```
`>>> say_whee()
Call 1 of 'say_whee'
Whee!

>>> say_whee()
Call 2 of 'say_whee'
Whee!

>>> say_whee.num_calls
2` 
```

### 类作为装饰器[](#classes-as-decorators "永久链接")

维持状态的典型方法是[使用类](https://realpython.com/python3-object-oriented-programming/)。在本节中，您将看到如何**使用类作为装饰器**重写`@count_calls`上一节中的示例。

回想一下装饰器语法`@my_decorator`只是一种更简单的说法`func = my_decorator(func)`。因此，如果`my_decorator`是类，则需要`func`在其`.__init__()`方法中将其作为参数。此外，该类实例必须是[可调用的，](https://docs.python.org/reference/datamodel.html#emulating-callable-objects)以便它可以代表修饰后的函数。

为了使可调用的类实例，可以实现特殊`.__call__()`方法：

```
`class Counter:
    def __init__(self, start=0):
        self.count = start

    def __call__(self):
        self.count += 1
        print(f"Current count is {self.count}")` 
```

`.__call__()`每次您尝试调用该类的实例时都会执行该方法：

\>>>

```
`>>> counter = Counter()
>>> counter()
Current count is 1

>>> counter()
Current count is 2

>>> counter.count
2` 
```

因此，装饰器类的典型实现需要实现`.__init__()`和`.__call__()`：

```
`import functools

class CountCalls:
    def __init__(self, func):
        functools.update_wrapper(self, func)
        self.func = func
        self.num_calls = 0

    def __call__(self, *args, **kwargs):
        self.num_calls += 1
        print(f"Call {self.num_calls} of {self.func.__name__!r}")
        return self.func(*args, **kwargs)

@CountCalls
def say_whee():
    print("Whee!")` 
```

该`.__init__()`方法必须存储对该函数的引用，并且可以执行任何其他必要的初始化。该`.__call__()`方法将被调用，而不是修饰的函数。它与`wrapper()`我们前面的示例中的函数基本上具有相同的作用。请注意，您需要使用[`functools.update_wrapper()`](https://docs.python.org/library/functools.html#functools.update_wrapper)函数而不是`@functools.wraps`。

该`@CountCalls`装饰器的工作原理与上一节中的装饰器相同：

\>>>

```
`>>> say_whee()
Call 1 of 'say_whee'
Whee!

>>> say_whee()
Call 2 of 'say_whee'
Whee!

>>> say_whee.num_calls
2` 
```

更多真实世界的例子[](#more-real-world-examples "永久链接")
---------------------------------------------

我们已经走了很长一段路，已经找到了如何创建各种装饰器的方法。总结一下，将我们新发现的知识用于创建更多示例，这些示例在现实世界中可能实际上是有用的。

### 再谈慢速代码[](#slowing-down-code-revisited "永久链接")

如前所述，我们[以前的实现`@slow_down`](#slowing-down-code)总是睡眠一秒钟。现在您知道了如何向装饰器添加参数，因此让我们`@slow_down`使用一个`rate`控制睡眠时间的可选参数来重写：

```
`import functools
import time

def slow_down(_func=None, *, rate=1):
    """Sleep given amount of seconds before calling the function"""
    def decorator_slow_down(func):
        @functools.wraps(func)
        def wrapper_slow_down(*args, **kwargs):
            time.sleep(rate)
            return func(*args, **kwargs)
        return wrapper_slow_down

    if _func is None:
        return decorator_slow_down
    else:
        return decorator_slow_down(_func)` 
```

我们正在使用“[请两个，但不要介意面包”](#both-please-but-never-mind-the-bread)一节中介绍的样板，使`@slow_down`带参数和不带参数的可调用都可调用。现在，与[之前](#slowing-down-code)相同的递归`countdown()`函数在每次计数之间睡眠两秒钟：[](#slowing-down-code)

```
`@slow_down(rate=2) def countdown(from_number):
    if from_number < 1:
        print("Liftoff!")
    else:
        print(from_number)
        countdown(from_number - 1)` 
```

和以前一样，您必须自己运行示例才能看到装饰器的效果：

\>>>

```
`>>> countdown(3)
3
2
1
Liftoff!` 
```

### 创建单例[](#creating-singletons "永久链接")

单例是只有一个实例的类。有几个单身Python中经常使用的，其中包括`None`，`True`，和`False`。事实上，这`None`是一个单例，它使您可以比较`None`使用[`is`关键字](https://realpython.com/python-is-identity-vs-equality/)，就像在“[请两个”](#both-please-but-never-mind-the-bread)部分中看到的那样：

```
`if _func is None:
    return decorator_name
else:
    return decorator_name(_func)` 
```

仅对完全相同实例的对象使用`is`return `True`。下面的`@singleton`装饰器通过将类的第一个实例存储为属性，将类变成单例。以后创建实例的尝试仅返回存储的实例：

```
`import functools

def singleton(cls):
    """Make a class a Singleton class (only one instance)"""
    @functools.wraps(cls)
    def wrapper_singleton(*args, **kwargs):
        if not wrapper_singleton.instance:
            wrapper_singleton.instance = cls(*args, **kwargs)
        return wrapper_singleton.instance
    wrapper_singleton.instance = None
    return wrapper_singleton

@singleton
class TheOne:
    pass` 
```

如您所见，此类装饰器遵循与函数装饰器相同的模板。唯一的区别是，我们使用`cls`而不是`func`作为参数名称来表示它打算用作类装饰器。

让我们看看它是否有效：

\>>>

```
`>>> first_one = TheOne()
>>> another_one = TheOne()

>>> id(first_one)
140094218762280

>>> id(another_one)
140094218762280

>>> first_one is another_one
True` 
```

显然，`first_one`确实与完全相同`another_one`。

**注意：**  Singleton类在Python中的使用并不像在其他语言中那样频繁。通常，将单例的效果更好地实现为模块中的全局变量。

### 缓存返回值[](#caching-return-values "永久链接")

装饰器可以提供一种很好的[缓存](https://en.wikipedia.org/wiki/Cache_%28computing%29)和[记忆](https://en.wikipedia.org/wiki/Memoization)机制。例如，让我们看一下[斐波那契数列](https://en.wikipedia.org/wiki/Fibonacci_number)的[递归](https://realpython.com/python-thinking-recursively/)定义：[](https://en.wikipedia.org/wiki/Fibonacci_number)

```
`from decorators import count_calls

@count_calls
def fibonacci(num):
    if num < 2:
        return num
    return fibonacci(num - 1) + fibonacci(num - 2)` 
```

尽管实现很简单，但其运行时性能却很糟糕：

\>>>

```
`>>> fibonacci(10)
<Lots of output from count_calls>
55

>>> fibonacci.num_calls
177` 
```

要计算第十个斐波那契数，您实际上只需要计算前面的斐波那契数，但是此实现需要某种程度的177次计算。它很快变得更糟：需要进行21891次计算，`fibonacci(20)`而第30个数字需要进行近270万次计算。这是因为代码会不断重新计算已知的斐波那契数。

通常的解决方案是使用`for`循环和查找表来实现斐波那契数。但是，简单的计算缓存也可以解决问题：

```
`import functools
from decorators import count_calls

def cache(func):
    """Keep a cache of previous function calls"""
    @functools.wraps(func)
    def wrapper_cache(*args, **kwargs):
        cache_key = args + tuple(kwargs.items())
        if cache_key not in wrapper_cache.cache:
            wrapper_cache.cache[cache_key] = func(*args, **kwargs)
        return wrapper_cache.cache[cache_key]
    wrapper_cache.cache = dict()
    return wrapper_cache

@cache @count_calls
def fibonacci(num):
    if num < 2:
        return num
    return fibonacci(num - 1) + fibonacci(num - 2)` 
```

缓存用作查找表，因此现在`fibonacci()`只执行一次必要的计算：

\>>>

```
`>>> fibonacci(10)
Call 1 of 'fibonacci'
...
Call 11 of 'fibonacci'
55

>>> fibonacci(8)
21` 
```

请注意，在最后一次调用时`fibonacci(8)`，不需要进行任何新的计算，因为已经计算了的第八个斐波那契数`fibonacci(10)`。

在标准库中，[最近使用最少的（LRU）缓存](https://realpython.com/lru-cache-python/)可用[`@functools.lru_cache`](https://docs.python.org/library/functools.html#functools.lru_cache)。

这个装饰器比您上面看到的具有更多功能。您应该使用`@functools.lru_cache`而不是编写自己的缓存装饰器：

```
`import functools

@functools.lru_cache(maxsize=4) def fibonacci(num):
 print(f"Calculating fibonacci({num})")    if num < 2:
        return num
    return fibonacci(num - 1) + fibonacci(num - 2)` 
```

该`maxsize`参数指定将缓存最近的调用数。默认值为128，但是您可以指定`maxsize=None`缓存所有函数调用。但是，请注意，如果要缓存许多大对象，这可能会导致内存问题。

您可以使用该`.cache_info()`方法查看缓存的性能，并且可以根据需要对其进行调整。在我们的示例中，我们使用了一个人为的小工具`maxsize`来查看从缓存中删除元素的效果：

\>>>

```
`>>> fibonacci(10)
Calculating fibonacci(10)
Calculating fibonacci(9)
Calculating fibonacci(8)
Calculating fibonacci(7)
Calculating fibonacci(6)
Calculating fibonacci(5)
Calculating fibonacci(4)
Calculating fibonacci(3)
Calculating fibonacci(2)
Calculating fibonacci(1)
Calculating fibonacci(0)
55

>>> fibonacci(8)
21

>>> fibonacci(5)
Calculating fibonacci(5)
Calculating fibonacci(4)
Calculating fibonacci(3)
Calculating fibonacci(2)
Calculating fibonacci(1)
Calculating fibonacci(0)
5

>>> fibonacci(8)
Calculating fibonacci(8)
Calculating fibonacci(7)
Calculating fibonacci(6)
21

>>> fibonacci(5)
5

>>> fibonacci.cache_info()
CacheInfo(hits=17, misses=20, maxsize=4, currsize=4)` 
```

### 添加有关单位的信息[](#adding-information-about-units "永久链接")

下面的示例与先前的[注册插件](#registering-plugins)示例有些相似，因为它并没有真正改变修饰函数的行为。相反，它只是简单地添加`unit`为一个函数属性：

```
`def set_unit(unit):
    """Register a unit on a function"""
    def decorator_set_unit(func):
        func.unit = unit
        return func
    return decorator_set_unit` 
```

以下示例根据圆柱体的半径和高度（以厘米为单位）计算圆柱体的体积：

```
`import math

@set_unit("cm^3")
def volume(radius, height):
    return math.pi * radius**2 * height` 
```

`.unit`以后可以在需要时访问此函数属性：

\>>>

```
`>>> volume(3, 5)
141.3716694115407

>>> volume.unit
'cm^3'` 
```

请注意，使用[功能注释](https://www.python.org/dev/peps/pep-3107/)可以实现类似的效果：

```
`import math

def volume(radius, height) -> "cm^3":
    return math.pi * radius**2 * height` 
```

但是，由于注释[用于类型提示](https://www.python.org/dev/peps/pep-0484/)，因此很难将诸如注释的单元与[静态类型检查](https://realpython.com/python-type-checking/#static-type-checking)结合起来。

与可在单元之间转换的库连接时，单元变得更加强大和有趣。一个这样的库是[`pint`](http://pint.readthedocs.io/)。通过`pint`安装（[`pip install Pint`](https://pypi.org/project/Pint/)），您可以例如将体积转换为立方英寸或加仑：

\>>>

```
`>>> import pint
>>> ureg = pint.UnitRegistry()
>>> vol = volume(3, 5) * ureg(volume.unit)

>>> vol
<Quantity(141.3716694115407, 'centimeter ** 3')>

>>> vol.to("cubic inches")
<Quantity(8.627028576414954, 'inch ** 3')>

>>> vol.to("gallons").m  # Magnitude
0.0373464440537444` 
```

您也可以修改装饰器以`pint` [`Quantity`](https://pint.readthedocs.io/en/latest/tutorial.html)直接返回一个。这样的`Quantity`通过乘以与所述单元的值制成。在中`pint`，必须在中查找单位`UnitRegistry`。注册表存储为一个函数属性，以避免使名称空间混乱：

```
`def use_unit(unit):
    """Have a function return a Quantity with given unit"""
    use_unit.ureg = pint.UnitRegistry()
    def decorator_use_unit(func):
        @functools.wraps(func)
        def wrapper_use_unit(*args, **kwargs):
            value = func(*args, **kwargs)
            return value * use_unit.ureg(unit)
        return wrapper_use_unit
    return decorator_use_unit

@use_unit("meters per second")
def average_speed(distance, duration):
    return distance / duration` 
```

使用`@use_unit`装饰器，转换单元几乎毫不费力：

\>>>

```
`>>> bolt = average_speed(100, 9.58)
>>> bolt
<Quantity(10.438413361169102, 'meter / second')>

>>> bolt.to("km per hour")
<Quantity(37.578288100208766, 'kilometer / hour')>

>>> bolt.to("mph").m  # Magnitude
23.350065679064745` 
```

### 验证JSON[](#validating-json "永久链接")

让我们看一下最后一个用例。快速浏览以下[Flask](https://realpython.com/tutorials/flask/)路由处理程序：

```
`@app.route("/grade", methods=["POST"])
def update_grade():
    json_data = request.get_json()
    if "student_id" not in json_data:
        abort(400)
    # Update database
    return "success!"` 
```

在这里，我们确保密钥`student_id`是请求的一部分。尽管此验证有效，但实际上不属于该函数本身。另外，也许还有其他路线使用完全相同的验证。因此，让它保持[DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)并使用装饰器抽象出任何不必要的逻辑。以下`@validate_json`装饰器将完成此工作：

```
`from flask import Flask, request, abort
import functools
app = Flask(__name__)

def validate_json(*expected_args):                  # 1
    def decorator_validate_json(func):
        @functools.wraps(func)
        def wrapper_validate_json(*args, **kwargs):
            json_object = request.get_json()
            for expected_arg in expected_args:      # 2
                if expected_arg not in json_object:
                    abort(400)
            return func(*args, **kwargs)
        return wrapper_validate_json
    return decorator_validate_json` 
```

在上面的代码中，装饰器将可变长度列表作为参数，以便我们可以根据需要传入尽可能多的字符串参数，每个参数均表示用于验证[JSON](https://realpython.com/python-json/)数据的密钥：

1.  JSON中必须存在的键列表作为装饰器的参数给出。
2.  包装函数验证JSON数据中是否存在每个预期的密钥。

然后，路由处理程序可以专注于其实际工作（更新等级），因为它可以安全地假定JSON数据有效：

```
`@app.route("/grade", methods=["POST"])
@validate_json("student_id")
def update_grade():
    json_data = request.get_json()
    # Update database.
    return "success!"` 
```

结论[](#conclusion "永久链接")
------------------------

这是一段漫长的旅程！在开始本教程时，我们先仔细了解了一些函数，尤其是如何在其他函数中定义它们并像其他任何Python对象一样传递它们。然后，您了解了装饰器以及如何编写这样的装饰器：

*   它们可以重复使用。
*   他们可以用参数装饰函数并返回值。
*   它们可以`@functools.wraps`用来看起来更像装饰功能。

在本教程的第二部分中，您看到了更多高级装饰器，并学习了如何：

*   装饰类
*   巢式装饰
*   向装饰器添加参数
*   在装饰器中保持状态
*   使用类作为装饰器

您已经看到，要定义装饰器，通常会定义一个返回包装函数的函数。包装函数使用`*args`和`**kwargs`将参数传递给装饰函数。如果希望装饰器也接受参数，则需要将包装函数嵌套在另一个函数中。在这种情况下，您通常以三个`return`语句结束。

您可以[在线从本教程中](https://github.com/realpython/materials/tree/master/primer-on-python-decorators)找到[代码](https://github.com/realpython/materials/tree/master/primer-on-python-decorators)。

进一步阅读[](#further-reading "永久链接")
--------------------------------

如果您仍在寻找更多内容，那么我们的《[Python Tricks》](https://realpython.com/products/python-tricks-book/)一书将介绍装饰器，David Beazley和Brian K. Jones撰写的[Python Cookbook](https://realpython.com/asins/1449340377/)也是如此。

要深入了解有关如何在Python中实现装饰器的历史讨论，请参见[PEP 318](https://www.python.org/dev/peps/pep-0318/)和[Python Decorator Wiki](https://wiki.python.org/moin/PythonDecorators)。装饰器的更多示例可以在[Python Decorator Library中找到](https://wiki.python.org/moin/PythonDecoratorLibrary)。该[`decorator`模块](https://github.com/micheles/decorator)可以简化创建自己的装饰器的过程，并且其[文档](https://decorator.readthedocs.io/)包含更多装饰器示例。

另外，我们为您整理了一个简短的Python装饰器备忘单： 
 [https://realpython.com/primer-on-python-decorators/](https://realpython.com/primer-on-python-decorators/)
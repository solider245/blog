---
title: git rebase&git merge合并与重新丁基
date: 2020-10-12 12:09:51
permalink: /pages/1d89d1/
categories:
  - git
  - git进阶
tags:
  - 
---
# 合并与重新定基

[概念概述](#conceptual-overview) [重新编制](#the-golden-rule-of-rebasing) [工作流](#workflow-walkthrough) [的黄金法则](#the-golden-rule-of-rebasing) [演练](#workflow-walkthrough) [摘要](#summary)

该 `git rebase` 命令以神奇的Git伏都教徒而闻名，初学者应该远离它，但是当谨慎使用时，它实际上可以使开发团队的生活变得更加轻松。 在本文中，我们将 `git rebase` 与相关 `git merge` 命令 进行比较 ， 并确定所有将潜在基础纳入典型Git工作流程的机会。

## 概念概述

首先要了解的 `git rebase` 是它解决了与相同的问题 `git merge` 。 这两个命令都是为了将​​更改从一个分支集成到另一个分支而设计的，它们只是以非常不同的方式来完成它。

考虑当您开始在专用分支中使用新功能，然后另一个团队成员 `master` 使用新的提交 更新 分支 时会发生什么 。 这将导致分叉的历史，对于使用Git作为协作工具的任何人都应该熟悉。

![分叉的提交历史](https://wac-cdn.atlassian.com/dam/jcr:01b0b04e-64f3-4659-af21-c4d86bc7cb0b/01.svg?cdnVersion=1084)

现在，假设新提交 `master` 的内容与您正在使用的功能有关。 要将新提交合并到您的 `feature` 分支中，您有两种选择：合并或重新设置。

### 合并选项

最简单的选择是 `master` 使用类似以下内容的方法 将 分支 合并 到功能分支中：

```
git checkout feature
git merge master
```

或者，您可以将其浓缩为单线：

```
git merge feature master
```

这会在 `feature` 分支中 创建一个新的“合并提交”，将 两个分支的历史联系在一起，从而为您提供如下所示的分支结构：

![将master合并到Feature分支](https://wac-cdn.atlassian.com/dam/jcr:e229fef6-2c2f-4a4f-b270-e1e1baa94055/02.svg?cdnVersion=1084)

合并非常好，因为它 *是非破坏性* 操作。 现有分支不会以任何方式更改。 这避免了重新设置基础的所有潜在陷阱（在下面讨论）。

另一方面，这也意味着 `feature` 每次需要合并上游更改时 ， 分支将具有无关的合并提交。 如果 `master` 非常活跃，这可能会污染您的功能分支的历史。 尽管可以使用高级 `git log` 选项 缓解此问题 ，但其他开发人员可能很难理解该项目的历史记录。

### 变基选项

作为合并的替代方法，可以 使用以下命令 将 `feature` 分支重新建立到 `master` 分支上：

```
git checkout feature
git rebase master
```

这会将整个 `feature` 分支 移到该 分支的尖端 `master` ，从而有效地合并了所有新提交 `master` 。 但是， *重新* 基准化不是使用合并提交，而是 通过为原始分支中的每个提交创建全新的提交来*重写* 项目历史记录。

![将功能分支重新建立到母版上](https://wac-cdn.atlassian.com/dam/jcr:5b153a22-38be-40d0-aec8-5f2fffc771e5/03.svg?cdnVersion=1084)

变基的主要好处是您可以获得更清晰的项目历史记录。 首先，它消除了所需的不必要的合并提交 `git merge` 。 其次，如您在上图中所看到的那样，重新定基也可以实现完美的线性项目历史记录\-您可以 `feature` 一路 沿用技巧 直到项目开始，而无需任何分支。 这使得它更容易浏览您的项目与命令一样 `git log` ， `git bisect` 和 `gitk` 。

但是，对于这个原始提交历史，有两个折衷：安全性和可追溯性。 如果您不遵循 重新 [定金](#the-golden-rule-of-rebasing) 的 [黄金法则，则](#the-golden-rule-of-rebasing) 重写项目历史记录可能会对您的协作工作流程造成灾难性的影响。 而且，更不重要的是，重新定基丢失了合并提交提供的上下文\-您看不到何时将上游更改合并到功能中。

### 互动基础

交互式重定基础使您有机会在提交移至新分支时更改提交。 由于它可以完全控制分支的提交历史，因此它甚至比自动重新设置功能更强大。 通常，这用于在合并功能分支之前清除混乱的历史记录 `master` 。

要开始交互式变基会话，请将 `i` 选项 传递 给 `git rebase` 命令：

```
git checkout feature
git rebase -i master
```

这将打开一个文本编辑器，列出所有将要移动的提交：

```
pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
```

此清单准确定义了执行变基后分支的外观。 通过更改 `pick` 命令和/或重新排序条目，您可以使分支的历史记录看起来像您想要的一样。 例如，如果第二个提交解决了第一个提交中的一个小问题，则可以使用以下 `fixup` 命令 将它们压缩为单个提交 ：

```
pick 33d5b7a Message for commit #1
fixup 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
```

当您保存并关闭文件时，Git将根据您的指示执行变基，从而产生类似于以下内容的项目历史记录：

![用交互式基础压缩提交](https://wac-cdn.atlassian.com/dam/jcr:fe6942b4-7a60-4464-9181-b67e59e50788/04.svg?cdnVersion=1084)

这样消除了无关紧要的提交，使您功能的历史记录更加容易理解。 这是 `git merge` 根本做不到的。

## 扎根的黄金法则

一旦了解了什么是基础，最重要的事情就是何时 *不* 进行基础 学习 。 的黄金法则 `git rebase` 是永远不要在 *公共* 分支 上使用它 。

例如，想想如果你重订基期会发生什么， `master` 在你的 `feature` 分支：

![重新分配主分支](https://wac-cdn.atlassian.com/dam/jcr:1d22f018-b2c7-4096-9db1-c54940cf4f4e/05.svg?cdnVersion=1084)

rebase将所有提交 `master` 移到的尖端 `feature` 。 问题是这仅发生在 *您的* 存储库中。 所有其他开发人员仍在使用原始版本 `master` 。 由于重新定基会带来全新的承诺，因此Git会认为您 `master` 分支的历史与其他人有所不同。

同步这两个 `master` 分支 的唯一方法 是将它们重新合并在一起，从而产生一个额外的合并提交 *和* 两组提交，这些提交包含相同的更改（原始更改和来自您的基于重新创建分支的更改）。 不用说，这是一个非常令人困惑的情况。

因此，在运行之前 `git rebase` ，请始终问自己：“还有其他人在看这个分支吗？” 如果答案是肯定的，请放开键盘，然后开始考虑一种无损方式进行更改（例如， `git revert` 命令）。 否则，您可以安全地随意重写历史记录。

### 推力

如果您尝试将重新建立基础的 `master` 分支 推 回远程存储库，Git将阻止您这样做，因为它与远程 `master` 分支 冲突 。 但是，您可以通过传递 `--force` 标志 来强制执行推送 ，如下所示：

```
# Be very careful with this command!
git push --force
```

这将覆盖远程 `master` 分支以匹配您的存储库中重新建立的分支，并使团队的其他成员感到非常困惑。 因此，只有当您确切知道自己在做什么时，请务必小心使用此命令。

一个唯一的时候，你应该力推动的是，当您进行了局部清理 *后，* 你推的私人特性分支到远程仓库（例如，用于备份的目的）。 这就像在说：“糟糕，我并不是真的想推送功能分支的原始版本。 以当前的替代。” 同样，重要的是没有人要处理来自功能分支原始版本的提交。

## 工作流程演练

只要您的团队感到满意，就可以将基础调整尽可能多地并入您现有的Git工作流程中。 在本节中，我们将研究在功能开发的各个阶段，重新定位可以带来的好处。

利用任何工作流程的第一步 `git rebase` 都是为每个功能创建一个专用分支。 这为您提供了必要的分支结构，以安全地使用重新基准化：

![在专用分支中开发功能](https://wac-cdn.atlassian.com/dam/jcr:6af9de07-088b-4f8b-97a7-b66569a9e4ac/06.svg?cdnVersion=1084)

### 本地清理

将基础整合到工作流中的最佳方法之一是清理本地的正在进行的功能。 通过定期执行交互式变基，可以确保功能中的每个提交都具有重点和意义。 这样，您就可以编写代码，而不必担心将其分解为孤立的提交，您可以在事后对其进行修复。

调用时 `git rebase` ，对于新的基础，您有两个选择：功能的父分支（例如 `master` ），或功能中的较早提交。 我们在“ *交互式基础调整”* 部分中 看到了第一个选项的示例 。 当您只需要修复最后的几次提交时，使用后一种方法是不错的选择。 例如，以下命令开始仅对最后3个提交进行交互式变基。

```
git checkout feature
git rebase -i HEAD~3
```

通过指定 `HEAD~3` 为新基础，您实际上并没有移动分支，而只是交互式地重写了紧随其后的3个提交。 请注意，这 *不会* 将上游更改合并到 `feature` 分支中。

![退缩到Head〜3](https://wac-cdn.atlassian.com/dam/jcr:079532c4-2594-40ed-a5c4-0e3621b9edff/07.svg?cdnVersion=1084)

如果要使用此方法重写整个功能，则该 `git merge-base` 命令对于查找 `feature` 分支 的原始库很有用 。 以下代码返回原始数据库的提交ID，然后您可以将其传递给 `git rebase` ：

```
git merge-base feature master
```

交互式重定基的这种使用是将其引入 `git rebase` 工作流程的 一种好方法 ，因为它仅影响本地分支机构。 其他开发人员唯一会看到的是成品，它应该是干净，易于遵循的功能分支历史记录。

但同样，这仅适用于 *私有* 功能分支。 如果您通过同一功能分支与其他开发人员进行协作，则该分支是 *public* ，并且您不能重写其历史记录。

没有 `git merge` 其他选择可以使用交互式资源库清除本地提交。

### 将上游更改纳入功能

在“ *概念概述”* 部分中，我们看到了功能分支如何通过 `master` 使用 `git merge` 或 来合并上游更改 `git rebase` 。 合并是一个安全的选项，可以保留存储库的整个历史记录，而重新基准化则通过将要素分支移到的尖端来创建线性历史记录 `master` 。

的使用 `git rebase` 类似于本地清理（并且可以同时执行），但是在此过程中，它合并了的上游提交 `master` 。

请记住，以远程分支代替，这是完全合法的 `master` 。 与另一位开发人员协作使用同一功能时，可能会发生这种情况，并且您需要将他们的更改合并到存储库中。

例如，如果您和另一个名为John的开发人员将提交添加到 `feature` 分支， `feature` 则从John的存储库中 获取远程 分支 后，您的存储库可能如下所示 ：

![在同一个功能分支上进行协作](https://wac-cdn.atlassian.com/dam/jcr:0bb661aa-361d-47ba-8c7b-00b3be0546cb/08.svg?cdnVersion=1084)

您可以使用与整合上游更改完全相同的方法来解决此派生 `master` ：将本地 `feature` 与 合并 `john/feature` ，或将本地重新建立 `feature` 到的尖端 `john/feature` 。

![合并与重新部署到远程分支](https://wac-cdn.atlassian.com/dam/jcr:1896adb1-5d49-419a-9b50-3a36adac186c/09.svg?cdnVersion=1084)

请注意，此重新设置不会违反“重新设置基础的 *黄金法则”，* 因为只有本地 `feature` 提交会被移动，而这之前的所有内容都不会被*更改* 。 这就像在说：“将我的更改添加到John已经完成的操作中。” 在大多数情况下，这比通过合并提交与远程分支同步更为直观。

默认情况下，该 `git pull` 命令执行合并，但是您可以通过将 `--rebase` 选项 传递给它来强制其将远程分支与rebase集成 。

### 通过拉取请求查看功能

如果将拉取请求用作代码检查过程的一部分，则需要避免 `git rebase` 在创建拉取请求后 使用 。 发出拉取请求后，其他开发人员就会查看您的提交，这意味着这是一个 *公共* 分支。 重写其历史记录将使Git和您的队友无法跟踪添加到该功能的任何后续落实。

其他开发商的任何修改都需要与被合并 `git merge` ，而不是 `git rebase` 。

出于这个原因，通常最好 *在* 提交请求*之前* 使用交互式rebase清理代码 。

### 集成批准的功能

在您的团队批准某个功能后，您可以选择将该功能重新部署到 `master` 分支 的顶端， 然后再 `git merge` 用于将该功能集成到主代码库中。

这类似于将上游更改合并到功能分支中，但是由于不允许您在 `master` 分支中 重写提交，因此 最终必须使用它 `git merge` 来集成功能。 但是，通过在合并之前执行重新设置基准，可以确保合并将快速进行，从而实现完美的线性历史记录。 这也使您有机会压缩在请求请求期间添加的任何后续提交。

![在有或没有基准的情况下将功能集成到母版中](https://wac-cdn.atlassian.com/dam/jcr:df39b1f1-2686-4ee5-90bf-9836783342ce/10.svg?cdnVersion=1084)

如果您不完全满意 `git rebase` ，则始终可以在临时分支中执行变基。 这样，如果您不小心弄乱了功能的历史记录，则可以签出原始分支，然后重试。 例如：

```
git checkout feature
git checkout -b temporary-branch
git rebase -i master
# [Clean up the history]
git checkout master
git merge temporary-branch
```

## 摘要

这就是您真正需要重新设置分支机构的全部信息。 如果您希望没有任何不必要的合并提交的干净，线性的历史记录，则应该争取 `git rebase` 而不是 `git merge` 在集成来自另一个分支的更改时使用。

另一方面，如果您想保留项目的完整历史记录并避免重写公共提交的风险，则可以坚持使用 `git merge` 。 两种选择都是完全有效的，但是至少现在您可以利用的好处 `git rebase` 。